# ‡∏£‡∏∞‡∏ö‡∏ö‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡πÅ‡∏•‡∏∞‡∏¢‡∏¥‡∏á‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö RoboMaster
# ‡πÅ‡∏¢‡∏Å‡∏≠‡∏≠‡∏Å‡∏°‡∏≤‡∏à‡∏≤‡∏Å walifwpare.py ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡πÉ‡∏ä‡πâ‡∏á‡∏≤‡∏ô‡πÑ‡∏î‡πâ‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏≠‡∏¥‡∏™‡∏£‡∏∞

import cv2
import numpy as np
import time
import threading
from datetime import datetime
from robomaster import blaster, gimbal, camera
import csv

#############################
# Object Detection Constants
#############################

# --- ‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏á‡∏ó‡∏µ‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á ---
WIDTH_SQUARE = 7.0
DIAMETER_CIRCLE = 7.0
WIDTH_RECT_H = 9.0
HEIGHT_RECT_H = 6.0
WIDTH_RECT_V = 6.0
HEIGHT_RECT_V = 9.0

# ‡∏£‡∏∞‡∏¢‡∏∞‡πÇ‡∏ü‡∏Å‡∏±‡∏™‡∏Ç‡∏≠‡∏á‡∏Å‡∏•‡πâ‡∏≠‡∏á‡∏ó‡∏µ‡πà‡πÑ‡∏î‡πâ‡∏à‡∏≤‡∏Å‡∏Å‡∏≤‡∏£‡∏Ñ‡∏≤‡∏•‡∏¥‡πÄ‡∏ö‡∏£‡∏ï (‡∏´‡∏ô‡πà‡∏ß‡∏¢: pixels)
FOCAL_LENGTH_PIXELS = 600

# ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏Ñ‡πà‡∏≤ Tolerance ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£ "‡πÄ‡∏à‡∏≠‡∏ï‡∏£‡∏á‡∏Å‡∏•‡∏≤‡∏á" (‡∏´‡∏ô‡πà‡∏ß‡∏¢: pixels)
CENTER_TOLERANCE = 20

# --- ‡∏Ñ‡πà‡∏≤‡∏Ñ‡∏á‡∏ó‡∏µ‡πà‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏ö‡∏Ñ‡∏∏‡∏° Gimbal ---
YAW_KP = 0.12
PITCH_KP = 0.15
MAX_YAW_SPEED = 60
MAX_PITCH_SPEED = 60

# ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏¢‡∏¥‡∏á‡∏ô‡πâ‡∏≥
FIRE_COOLDOWN = 2.0  # ‡∏£‡∏∞‡∏¢‡∏∞‡πÄ‡∏ß‡∏•‡∏≤‡∏´‡∏ô‡πà‡∏ß‡∏á‡∏£‡∏∞‡∏´‡∏ß‡πà‡∏≤‡∏á‡∏Å‡∏≤‡∏£‡∏¢‡∏¥‡∏á (‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ)

# ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏Å‡∏£‡∏≠‡∏á‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏°
MIN_AREA = 1500
MIN_WIDTH = 40
MIN_HEIGHT = 40
MAX_ASPECT_RATIO = 4.0
MIN_ASPECT_RATIO = 0.25

# --- ‡∏Å‡∏≥‡∏´‡∏ô‡∏î‡∏ä‡πà‡∏ß‡∏á‡∏™‡∏µ‡πÅ‡∏•‡∏∞‡∏™‡∏µ‡∏Ç‡∏≠‡∏á‡∏Å‡∏£‡∏≠‡∏ö (HSV + BGR ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö bounding box) ---
color_ranges = {
    "red":            ([0, 120, 70],   [10, 255, 255],   (0, 0, 255)),
    "dark_green":     ([70, 150, 20],   [90, 255, 70],    (0, 255, 0)),
    "yellow_brown":   ([15, 150, 80],   [30, 255, 180],   (0, 255, 255)),
    "dark_blue":      ([110, 150, 30],  [130, 255, 100],  (255, 0, 0)),
}

# ‡∏ä‡πà‡∏ß‡∏á‡∏™‡∏µ‡πÅ‡∏î‡∏á‡πÄ‡∏û‡∏¥‡πà‡∏°‡πÄ‡∏ï‡∏¥‡∏° (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö HSV wraparound)
red_ranges_extended = [
    ([0, 120, 70], [10, 255, 255]),      # ‡πÅ‡∏î‡∏á‡∏™‡πâ‡∏°
    ([170, 120, 70], [180, 255, 255]),   # ‡πÅ‡∏î‡∏á‡∏°‡πà‡∏ß‡∏á
    ([0, 80, 100], [15, 255, 255]),      # ‡πÅ‡∏î‡∏á‡∏≠‡πà‡∏≠‡∏ô
    ([165, 80, 100], [180, 255, 255])    # ‡πÅ‡∏î‡∏á‡πÄ‡∏Ç‡πâ‡∏°
]

# ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏¢‡∏¥‡∏á
shot_objects = {}  # ‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏¢‡∏¥‡∏á {(x, y): [{'color': str, 'shape': str, 'timestamp': datetime, 'distance': float}]}
shot_objects_lock = threading.Lock()  # ‡∏õ‡πâ‡∏≠‡∏á‡∏Å‡∏±‡∏ô‡∏Å‡∏≤‡∏£‡πÄ‡∏Ç‡πâ‡∏≤‡∏ñ‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏û‡∏£‡πâ‡∏≠‡∏°‡∏Å‡∏±‡∏ô

# ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö object detection
object_detection_enabled = True
current_frame = None
frame_lock = threading.Lock()

# ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Color Range Adjustment Window
current_color_index = 0  # 0: red, 1: dark_green, 2: yellow_brown, 3: dark_blue
color_names = ["red", "dark_green", "yellow_brown", "dark_blue"]

# ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Mask Display Window
show_mask = True  # ‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡πÅ‡∏™‡∏î‡∏á mask
enable_equalization = True  # ‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î‡∏Å‡∏≤‡∏£‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏ß‡πà‡∏≤‡∏á
show_detection_window = True  # ‡πÄ‡∏õ‡∏¥‡∏î/‡∏õ‡∏¥‡∏î‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á‡πÅ‡∏™‡∏î‡∏á‡∏ú‡∏•‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö

# ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö Detection Display Thread
detection_thread_running = False

#############################
# Object Detection Functions
#############################

def create_red_mask(hsv_image):
    """‡∏™‡∏£‡πâ‡∏≤‡∏á mask ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏µ‡πÅ‡∏î‡∏á‡∏ó‡∏µ‡πà‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡πÅ‡∏•‡πâ‡∏ß ‡∏£‡∏≠‡∏á‡∏£‡∏±‡∏ö HSV wraparound ‡πÅ‡∏•‡∏∞‡∏õ‡∏£‡∏±‡∏ö‡∏ï‡∏≤‡∏°‡∏™‡∏†‡∏≤‡∏û‡πÅ‡∏™‡∏á"""
    # ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢‡∏Ç‡∏≠‡∏á‡∏†‡∏≤‡∏û
    avg_brightness = np.mean(hsv_image[:,:,2])
    
    # ‡πÄ‡∏•‡∏∑‡∏≠‡∏Å‡∏ä‡πà‡∏ß‡∏á‡∏™‡∏µ‡πÅ‡∏î‡∏á‡∏ó‡∏µ‡πà‡πÄ‡∏´‡∏°‡∏≤‡∏∞‡∏™‡∏°‡∏ï‡∏≤‡∏°‡∏™‡∏†‡∏≤‡∏û‡πÅ‡∏™‡∏á
    red_ranges = adaptive_red_ranges(avg_brightness)
    
    # ‡∏™‡∏£‡πâ‡∏≤‡∏á mask ‡∏£‡∏ß‡∏°‡∏à‡∏≤‡∏Å‡∏´‡∏•‡∏≤‡∏¢‡∏ä‡πà‡∏ß‡∏á‡∏™‡∏µ‡πÅ‡∏î‡∏á
    combined_mask = np.zeros(hsv_image.shape[:2], dtype=np.uint8)
    
    for lower, upper in red_ranges:
        mask = cv2.inRange(hsv_image, np.array(lower), np.array(upper))
        combined_mask = cv2.bitwise_or(combined_mask, mask)
    
    # ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á mask ‡∏î‡πâ‡∏ß‡∏¢ morphological operations ‡∏ï‡∏≤‡∏°‡∏™‡∏†‡∏≤‡∏û‡πÅ‡∏™‡∏á
    if avg_brightness < 100:  # ‡πÅ‡∏™‡∏á‡∏ô‡πâ‡∏≠‡∏¢ - ‡πÉ‡∏ä‡πâ kernel ‡πÉ‡∏´‡∏ç‡πà‡∏Ç‡∏∂‡πâ‡∏ô
        kernel = np.ones((4, 4), np.uint8)
        combined_mask = cv2.morphologyEx(combined_mask, cv2.MORPH_OPEN, kernel, iterations=1)
        combined_mask = cv2.morphologyEx(combined_mask, cv2.MORPH_CLOSE, kernel, iterations=3)
        combined_mask = cv2.dilate(combined_mask, kernel, iterations=2)
    elif avg_brightness > 180:  # ‡πÅ‡∏™‡∏á‡∏°‡∏≤‡∏Å - ‡πÉ‡∏ä‡πâ kernel ‡πÄ‡∏•‡πá‡∏Å‡∏•‡∏á
        kernel = np.ones((2, 2), np.uint8)
        combined_mask = cv2.morphologyEx(combined_mask, cv2.MORPH_OPEN, kernel, iterations=2)
        combined_mask = cv2.morphologyEx(combined_mask, cv2.MORPH_CLOSE, kernel, iterations=1)
        combined_mask = cv2.dilate(combined_mask, kernel, iterations=1)
    else:  # ‡πÅ‡∏™‡∏á‡∏õ‡∏Å‡∏ï‡∏¥
        kernel = np.ones((3, 3), np.uint8)
        combined_mask = cv2.morphologyEx(combined_mask, cv2.MORPH_OPEN, kernel, iterations=1)
        combined_mask = cv2.morphologyEx(combined_mask, cv2.MORPH_CLOSE, kernel, iterations=2)
        combined_mask = cv2.dilate(combined_mask, kernel, iterations=1)
    
    return combined_mask

def enhance_red_detection(roi_frame):
    """‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏†‡∏≤‡∏û‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏™‡∏µ‡πÅ‡∏î‡∏á‡∏ó‡∏µ‡πà‡∏î‡∏µ‡∏Ç‡∏∂‡πâ‡∏ô"""
    # ‡πÅ‡∏õ‡∏•‡∏á‡πÄ‡∏õ‡πá‡∏ô HSV
    hsv = cv2.cvtColor(roi_frame, cv2.COLOR_BGR2HSV)
    
    # ‡∏ß‡∏¥‡πÄ‡∏Ñ‡∏£‡∏≤‡∏∞‡∏´‡πå‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏â‡∏•‡∏µ‡πà‡∏¢‡∏Ç‡∏≠‡∏á‡∏†‡∏≤‡∏û
    avg_brightness = np.mean(hsv[:,:,2])
    
    # ‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏Ñ‡∏ß‡∏≤‡∏°‡∏≠‡∏¥‡πà‡∏°‡∏ï‡∏±‡∏ß‡∏Ç‡∏≠‡∏á‡∏™‡∏µ (Saturation) ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡πÉ‡∏´‡πâ‡∏™‡∏µ‡πÅ‡∏î‡∏á‡∏ä‡∏±‡∏î‡∏Ç‡∏∂‡πâ‡∏ô
    if avg_brightness < 100:  # ‡∏™‡∏†‡∏≤‡∏û‡πÅ‡∏™‡∏á‡∏ô‡πâ‡∏≠‡∏¢
        hsv[:,:,1] = cv2.multiply(hsv[:,:,1], 1.4)  # ‡πÄ‡∏û‡∏¥‡πà‡∏° saturation ‡∏°‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô
        hsv[:,:,2] = cv2.add(hsv[:,:,2], 20)  # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏ß‡πà‡∏≤‡∏á‡∏°‡∏≤‡∏Å‡∏Ç‡∏∂‡πâ‡∏ô
    elif avg_brightness > 200:  # ‡∏™‡∏†‡∏≤‡∏û‡πÅ‡∏™‡∏á‡∏°‡∏≤‡∏Å
        hsv[:,:,1] = cv2.multiply(hsv[:,:,1], 1.1)  # ‡πÄ‡∏û‡∏¥‡πà‡∏° saturation ‡∏ô‡πâ‡∏≠‡∏¢
        hsv[:,:,2] = cv2.subtract(hsv[:,:,2], 5)  # ‡∏•‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏ß‡πà‡∏≤‡∏á‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢
    else:  # ‡∏™‡∏†‡∏≤‡∏û‡πÅ‡∏™‡∏á‡∏õ‡∏Å‡∏ï‡∏¥
        hsv[:,:,1] = cv2.multiply(hsv[:,:,1], 1.2)  # ‡πÄ‡∏û‡∏¥‡πà‡∏° saturation ‡∏õ‡∏Å‡∏ï‡∏¥
        hsv[:,:,2] = cv2.add(hsv[:,:,2], 10)  # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏ß‡πà‡∏≤‡∏á‡∏õ‡∏Å‡∏ï‡∏¥
    
    # ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Ñ‡πà‡∏≤‡πÉ‡∏´‡πâ‡∏≠‡∏¢‡∏π‡πà‡πÉ‡∏ô‡∏ä‡πà‡∏ß‡∏á‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á
    hsv[:,:,1] = np.clip(hsv[:,:,1], 0, 255)
    hsv[:,:,2] = np.clip(hsv[:,:,2], 0, 255)
    
    return hsv

def adaptive_red_ranges(avg_brightness):
    """‡∏õ‡∏£‡∏±‡∏ö‡∏ä‡πà‡∏ß‡∏á‡∏™‡∏µ‡πÅ‡∏î‡∏á‡∏ï‡∏≤‡∏°‡∏™‡∏†‡∏≤‡∏û‡πÅ‡∏™‡∏á"""
    if avg_brightness < 80:  # ‡πÅ‡∏™‡∏á‡∏ô‡πâ‡∏≠‡∏¢‡∏°‡∏≤‡∏Å
        return [
            ([0, 100, 30], [15, 255, 255]),      # ‡∏Ç‡∏¢‡∏≤‡∏¢‡∏ä‡πà‡∏ß‡∏á H ‡πÅ‡∏•‡∏∞‡∏•‡∏î S minimum
            ([165, 100, 30], [180, 255, 255]),
            ([0, 60, 50], [20, 255, 255]),       # ‡∏ä‡πà‡∏ß‡∏á‡∏Å‡∏ß‡πâ‡∏≤‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏™‡∏á‡∏ô‡πâ‡∏≠‡∏¢
            ([160, 60, 50], [180, 255, 255])
        ]
    elif avg_brightness > 180:  # ‡πÅ‡∏™‡∏á‡∏°‡∏≤‡∏Å‡∏°‡∏≤‡∏Å
        return [
            ([0, 140, 100], [8, 255, 255]),      # ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏ä‡πà‡∏ß‡∏á H ‡πÅ‡∏•‡∏∞‡πÄ‡∏û‡∏¥‡πà‡∏° S minimum
            ([172, 140, 100], [180, 255, 255]),
            ([0, 120, 120], [12, 255, 255]),     # ‡∏ä‡πà‡∏ß‡∏á‡πÅ‡∏Ñ‡∏ö‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÅ‡∏™‡∏á‡∏°‡∏≤‡∏Å
            ([168, 120, 120], [180, 255, 255])
        ]
    else:  # ‡πÅ‡∏™‡∏á‡∏õ‡∏Å‡∏ï‡∏¥
        return red_ranges_extended

def detect_shape(contour):
    """‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏π‡∏õ‡∏£‡πà‡∏≤‡∏á‡πÉ‡∏´‡πâ‡πÄ‡∏Ç‡πâ‡∏°‡∏á‡∏ß‡∏î‡∏Ç‡∏∂‡πâ‡∏ô"""
    shape = "Unknown"
    perimeter = cv2.arcLength(contour, True)
    area = cv2.contourArea(contour)
    
    # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥
    if area < MIN_AREA:
        return "Unknown"
    
    # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Solidity ‡∏≠‡∏µ‡∏Å‡∏Ñ‡∏£‡∏±‡πâ‡∏á‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÅ‡∏ô‡πà‡∏ô‡∏≠‡∏ô
    hull = cv2.convexHull(contour)
    hull_area = cv2.contourArea(hull)
    if hull_area > 0:
        solidity = float(area) / hull_area
        if solidity < 0.85:  # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏Ç‡πâ‡∏°‡∏á‡∏ß‡∏î
            return "Unknown"
    
    # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Extent (‡∏≠‡∏±‡∏ï‡∏£‡∏≤‡∏™‡πà‡∏ß‡∏ô‡∏Ç‡∏≠‡∏á‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡πà‡∏≠‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà bounding box)
    x, y, w, h = cv2.boundingRect(contour)
    bounding_area = w * h
    if bounding_area > 0:
        extent = float(area) / bounding_area
        if extent < 0.7:  # ‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏ï‡πâ‡∏≠‡∏á‡πÄ‡∏ï‡∏¥‡∏°‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 70% ‡∏Ç‡∏≠‡∏á bounding box
            return "Unknown"
    
    # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥‡∏Ç‡∏≠‡∏á bounding box
    if w < MIN_WIDTH or h < MIN_HEIGHT:
        return "Unknown"
    
    # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏±‡∏î‡∏™‡πà‡∏ß‡∏ô (‡πÑ‡∏°‡πà‡πÉ‡∏´‡πâ‡∏¢‡∏≤‡∏ß‡πÄ‡∏Å‡∏¥‡∏ô‡πÑ‡∏õ)
    aspect_ratio = float(w) / h
    if aspect_ratio > MAX_ASPECT_RATIO or aspect_ratio < MIN_ASPECT_RATIO:
        return "Unknown"
    
    # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Circularity ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ß‡∏á‡∏Å‡∏•‡∏°
    circularity = 4 * np.pi * area / (perimeter * perimeter)
    
    # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏£‡∏π‡∏õ‡∏£‡πà‡∏≤‡∏á
    approx = cv2.approxPolyDP(contour, 0.04 * perimeter, True)
    num_vertices = len(approx)

    if num_vertices == 4:
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏∏‡∏°‡πÉ‡∏Å‡∏•‡πâ‡πÄ‡∏Ñ‡∏µ‡∏¢‡∏á 90 ‡∏≠‡∏á‡∏®‡∏≤ (‡πÄ‡∏õ‡πá‡∏ô‡∏™‡∏µ‡πà‡πÄ‡∏´‡∏•‡∏µ‡πà‡∏¢‡∏°)
        angles = []
        for i in range(4):
            p1 = approx[i][0]
            p2 = approx[(i+1)%4][0]
            p3 = approx[(i+2)%4][0]
            
            # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì‡∏°‡∏∏‡∏°
            v1 = p1 - p2
            v2 = p3 - p2
            cos_angle = np.dot(v1, v2) / (np.linalg.norm(v1) * np.linalg.norm(v2))
            cos_angle = np.clip(cos_angle, -1.0, 1.0)
            angle = np.arccos(cos_angle) * 180 / np.pi
            angles.append(angle)
        
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡∏°‡∏∏‡∏°‡πÉ‡∏Å‡∏•‡πâ‡πÄ‡∏Ñ‡∏µ‡∏¢‡∏á 90 ‡∏≠‡∏á‡∏®‡∏≤ (80-100 ‡∏≠‡∏á‡∏®‡∏≤)
        valid_angles = sum(1 for a in angles if 80 <= a <= 100)
        if valid_angles < 3:  # ‡∏ï‡πâ‡∏≠‡∏á‡∏°‡∏µ‡∏°‡∏∏‡∏°‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏ï‡πâ‡∏≠‡∏á‡∏≠‡∏¢‡πà‡∏≤‡∏á‡∏ô‡πâ‡∏≠‡∏¢ 3 ‡∏°‡∏∏‡∏°
            return "Unknown"
        
        # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö aspect ratio
        if 0.9 <= aspect_ratio <= 1.1:
            shape = "Square"
        elif aspect_ratio > 1.2:  # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏Ç‡πâ‡∏°‡∏á‡∏ß‡∏î
            shape = "Rectangle-H"
        elif aspect_ratio < 0.8:  # ‡πÄ‡∏û‡∏¥‡πà‡∏°‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏Ç‡πâ‡∏°‡∏á‡∏ß‡∏î
            shape = "Rectangle-V"
        else:
            return "Unknown"
            
    elif num_vertices > 6 and circularity > 0.8:  # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö circularity
        shape = "Circle"
        
    return shape

def process_frame_for_objects(frame):
    """‡∏õ‡∏£‡∏∞‡∏°‡∏ß‡∏•‡∏ú‡∏•‡∏†‡∏≤‡∏û‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡πÅ‡∏•‡∏∞‡∏™‡πà‡∏á‡∏Ñ‡∏∑‡∏ô‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢"""
    if frame is None:
        return None, False
    
    frame_height, frame_width, _ = frame.shape

    roi_w = 800
    roi_h = 450
    roi_x = (frame_width - roi_w) // 2
    roi_y = (frame_height - roi_h) // 2
    
    roi_center_x = roi_w // 2
    roi_center_y = roi_h // 2

    roi_frame = frame[roi_y:roi_y + roi_h, roi_x:roi_x + roi_w]
    
    # ‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡∏ß‡∏≤‡∏°‡∏™‡∏ß‡πà‡∏≤‡∏á‡∏Ç‡∏≠‡∏á‡∏†‡∏≤‡∏û‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏™‡∏ñ‡∏µ‡∏¢‡∏£‡πÉ‡∏ô‡∏Å‡∏≤‡∏£ detect ‡∏™‡∏µ
    lab = cv2.cvtColor(roi_frame, cv2.COLOR_BGR2LAB)
    lab[:,:,0] = cv2.createCLAHE(clipLimit=3.0, tileGridSize=(8,8)).apply(lab[:,:,0])
    roi_frame = cv2.cvtColor(lab, cv2.COLOR_LAB2BGR)
    
    # ‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏Å‡∏≤‡∏£‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏™‡∏µ‡πÅ‡∏î‡∏á
    hsv = enhance_red_detection(roi_frame)
    
    # ‡∏ï‡∏±‡∏ß‡πÅ‡∏õ‡∏£‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡πÄ‡∏Å‡πá‡∏ö‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡∏ó‡∏µ‡πà‡πÉ‡∏´‡∏ç‡πà‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡πÉ‡∏ô‡πÄ‡∏ü‡∏£‡∏°‡∏ô‡∏µ‡πâ
    biggest_contour_area = 0
    target_x_offset = 0
    target_y_offset = 0
    found_target_in_frame = False
    target_info = None

    for color_name, (lower, upper, box_color) in color_ranges.items():
        # ‡πÉ‡∏ä‡πâ‡∏ü‡∏±‡∏á‡∏Å‡πå‡∏ä‡∏±‡∏ô‡∏û‡∏¥‡πÄ‡∏®‡∏©‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏µ‡πÅ‡∏î‡∏á
        if color_name == "red":
            mask = create_red_mask(hsv)
        else:
            mask = cv2.inRange(hsv, np.array(lower), np.array(upper))
            # ‡πÄ‡∏û‡∏¥‡πà‡∏° Morphology Operations ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏õ‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏∏‡∏á mask ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏™‡∏µ‡∏≠‡∏∑‡πà‡∏ô
            kernel = np.ones((5, 5), np.uint8)
            mask = cv2.erode(mask, kernel, iterations=1)
            mask = cv2.dilate(mask, kernel, iterations=1)
        
        contours, _ = cv2.findContours(mask, cv2.RETR_EXTERNAL, cv2.CHAIN_APPROX_SIMPLE)
        
        for cnt in contours:
            area = cv2.contourArea(cnt)
            if area > MIN_AREA:
                # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î‡πÅ‡∏•‡∏∞‡∏™‡∏±‡∏î‡∏™‡πà‡∏ß‡∏ô‡∏Ç‡∏≠‡∏á bounding box
                x, y, w, h = cv2.boundingRect(cnt)
                
                # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏Ç‡∏ô‡∏≤‡∏î‡∏Ç‡∏±‡πâ‡∏ô‡∏ï‡πà‡∏≥
                if w < MIN_WIDTH or h < MIN_HEIGHT:
                    continue
                
                # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏™‡∏±‡∏î‡∏™‡πà‡∏ß‡∏ô
                aspect_ratio = float(w) / h
                if aspect_ratio > MAX_ASPECT_RATIO or aspect_ratio < MIN_ASPECT_RATIO:
                    continue
                
                # ‡∏Ñ‡∏≥‡∏ô‡∏ß‡∏ì Solidity ‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏Å‡∏£‡∏≠‡∏á noise ‡∏´‡∏£‡∏∑‡∏≠ contour ‡∏ó‡∏µ‡πà‡∏ú‡∏¥‡∏î‡∏õ‡∏Å‡∏ï‡∏¥
                hull = cv2.convexHull(cnt)
                hull_area = cv2.contourArea(hull)
                if hull_area > 0:
                    solidity = float(area) / hull_area
                    if solidity < 0.85:
                        continue

                shape_name = detect_shape(cnt)
                
                if shape_name != "Unknown":
                    distance_cm = 0
                    new_x, new_y = 0, 0
                    
                    if shape_name == "Circle":
                        (x_c, y_c), radius = cv2.minEnclosingCircle(cnt)
                        new_x = int(x_c - roi_center_x)
                        new_y = int(roi_center_y - y_c)
                        
                        if radius > 0:
                            pixel_diameter = 2 * radius
                            distance_cm = (DIAMETER_CIRCLE * FOCAL_LENGTH_PIXELS) / pixel_diameter
                    
                    else: # Square or Rectangle
                        x, y, w, h = cv2.boundingRect(cnt)
                        obj_center_x = x + w // 2
                        obj_center_y = y + h // 2
                        new_x = int(obj_center_x - roi_center_x)
                        new_y = int(roi_center_y - obj_center_y)
                        
                        if shape_name == "Square":
                            distance_cm = (WIDTH_SQUARE * FOCAL_LENGTH_PIXELS) / h
                        elif shape_name == "Rectangle-V":
                            distance_cm = (HEIGHT_RECT_V * FOCAL_LENGTH_PIXELS) / h
                        elif shape_name == "Rectangle-H":
                            distance_cm = (WIDTH_RECT_H * FOCAL_LENGTH_PIXELS) / w

                    # ‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡∏ß‡πà‡∏≤‡πÄ‡∏õ‡πá‡∏ô contour ‡∏ó‡∏µ‡πà‡πÉ‡∏´‡∏ç‡πà‡∏ó‡∏µ‡πà‡∏™‡∏∏‡∏î‡∏ó‡∏µ‡πà‡πÄ‡∏à‡∏≠‡πÉ‡∏ô‡πÄ‡∏ü‡∏£‡∏°‡∏ô‡∏µ‡πâ‡∏´‡∏£‡∏∑‡∏≠‡πÑ‡∏°‡πà
                    if area > biggest_contour_area:
                        biggest_contour_area = area
                        target_x_offset = new_x
                        target_y_offset = new_y
                        found_target_in_frame = True
                        target_info = {
                            'color': color_name,
                            'shape': shape_name,
                            'distance': distance_cm,
                            'x_offset': new_x,
                            'y_offset': new_y
                        }

                    # ‡∏™‡πà‡∏ß‡∏ô‡∏ï‡∏£‡∏ß‡∏à‡∏™‡∏≠‡∏ö‡πÅ‡∏•‡∏∞‡∏Ñ‡∏∑‡∏ô‡∏Ñ‡πà‡∏≤‡πÄ‡∏°‡∏∑‡πà‡∏≠‡πÄ‡∏à‡∏≠‡∏ï‡∏£‡∏á‡∏Å‡∏•‡∏≤‡∏á
                    if abs(new_x) <= CENTER_TOLERANCE and abs(new_y) <= CENTER_TOLERANCE:
                        print(f"‡πÄ‡∏à‡∏≠‡∏ï‡∏£‡∏á‡∏Å‡∏•‡∏≤‡∏á‡∏Ç‡∏≠‡∏á {color_name} {shape_name}! | ‡∏û‡∏¥‡∏Å‡∏±‡∏î: ({new_x}, {new_y}) | ‡∏£‡∏∞‡∏¢‡∏∞‡∏ó‡∏≤‡∏á: {distance_cm:.1f} cm")
                        return target_info, True

    if found_target_in_frame:
        return target_info, False
    
    return None, False

#############################
# Shooting System Class
#############################

class ShootingSystem:
    """‡∏Ñ‡∏•‡∏≤‡∏™‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏à‡∏±‡∏î‡∏Å‡∏≤‡∏£‡∏£‡∏∞‡∏ö‡∏ö‡∏Å‡∏≤‡∏£‡∏¢‡∏¥‡∏á‡πÅ‡∏•‡∏∞‡∏ï‡∏£‡∏ß‡∏à‡∏à‡∏±‡∏ö‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏"""
    
    def __init__(self, ep_robot):
        """
        ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏£‡∏∞‡∏ö‡∏ö‡∏Å‡∏≤‡∏£‡∏¢‡∏¥‡∏á
        
        Args:
            ep_robot: RoboMaster robot instance
        """
        self.ep_robot = ep_robot
        self.ep_gimbal = ep_robot.gimbal
        self.ep_blaster = ep_robot.blaster
        self.ep_camera = ep_robot.camera
        self.last_fire_time = 0
        
        # ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô blaster
        self.ep_blaster.set_fire_count(300)
        
    def fire_at_target(self, target_info, robot_position=None):
        """
        ‡∏¢‡∏¥‡∏á‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏ö‡∏∏
        
        Args:
            target_info: ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢
            robot_position: ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏Ç‡∏≠‡∏á‡∏´‡∏∏‡πà‡∏ô‡∏¢‡∏ô‡∏ï‡πå (‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å)
        
        Returns:
            bool: True ‡∏ñ‡πâ‡∏≤‡∏¢‡∏¥‡∏á‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à, False ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à
        """
        current_time = time.time()
        if current_time - self.last_fire_time >= FIRE_COOLDOWN:
            print("üî• ‡∏¢‡∏¥‡∏á‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢!")
            
            # ‡∏õ‡∏£‡∏±‡∏ö gimbal ‡∏Ç‡∏∂‡πâ‡∏ô‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢‡∏Å‡πà‡∏≠‡∏ô‡∏¢‡∏¥‡∏á
            self.ep_gimbal.move(pitch=8, pitch_speed=40).wait_for_completed()
            time.sleep(0.2)
            
            # ‡∏¢‡∏¥‡∏á
            self.ep_blaster.fire(fire_type=blaster.WATER_FIRE, times=70)
            self.last_fire_time = current_time
            
            # ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏¢‡∏¥‡∏á
            if robot_position is not None:
                record_shot_object(target_info, robot_position)
            
            # ‡∏Å‡∏•‡∏±‡∏ö‡∏•‡∏á‡∏°‡∏≤‡∏´‡∏•‡∏±‡∏á‡∏¢‡∏¥‡∏á
            self.ep_gimbal.move(pitch=-8, pitch_speed=30).wait_for_completed()
            
            return True
        else:
            print(f"‚è≥ ‡∏£‡∏≠ cooldown ‡∏≠‡∏µ‡∏Å {FIRE_COOLDOWN - (current_time - self.last_fire_time):.1f} ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ")
            return False
    
    def track_and_shoot_target(self, target_info, max_tracking_time=10.0):
        """
        ‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡πÅ‡∏•‡∏∞‡∏¢‡∏¥‡∏á‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢
        
        Args:
            target_info: ‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô
            max_tracking_time: ‡πÄ‡∏ß‡∏•‡∏≤‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏° (‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ)
        
        Returns:
            bool: True ‡∏ñ‡πâ‡∏≤‡∏¢‡∏¥‡∏á‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à, False ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏™‡∏≥‡πÄ‡∏£‡πá‡∏à
        """
        print(f"üéØ ‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢: {target_info['color']} {target_info['shape']}")
        
        tracking_start_time = time.time()
        
        while time.time() - tracking_start_time < max_tracking_time:
            try:
                img = self.ep_camera.read_cv2_image(strategy="newest", timeout=0.1)
                if img is not None:
                    current_target, is_centered = process_frame_for_objects(img)
                    
                    if current_target:
                        if is_centered:
                            # ‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏≠‡∏¢‡∏π‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏•‡∏≤‡∏á - ‡∏¢‡∏¥‡∏á!
                            if self.fire_at_target(current_target):
                                print("‚úÖ ‡∏Å‡∏≤‡∏£‡∏¢‡∏¥‡∏á‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô")
                                return True
                        else:
                            # ‡∏õ‡∏£‡∏±‡∏ö gimbal ‡πÑ‡∏õ‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢
                            yaw_speed = YAW_KP * current_target['x_offset']
                            pitch_speed = PITCH_KP * current_target['y_offset']
                            
                            # ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î
                            yaw_speed = np.clip(yaw_speed, -MAX_YAW_SPEED, MAX_YAW_SPEED)
                            pitch_speed = np.clip(pitch_speed, -MAX_PITCH_SPEED, MAX_PITCH_SPEED)
                            
                            self.ep_gimbal.drive_speed(yaw_speed=yaw_speed, pitch_speed=pitch_speed)
                            time.sleep(0.05)
                    else:
                        # ‡∏´‡∏≤‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠ ‡πÉ‡∏´‡πâ‡∏´‡∏¢‡∏∏‡∏î‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°
                        print("‚ö†Ô∏è ‡∏™‡∏π‡∏ç‡πÄ‡∏™‡∏µ‡∏¢‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢ ‡∏´‡∏¢‡∏∏‡∏î‡∏Å‡∏≤‡∏£‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°")
                        self.ep_gimbal.drive_speed(yaw_speed=0, pitch_speed=0)
                        break
                        
            except Exception as e:
                print(f"‚ö†Ô∏è ‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢: {e}")
                break
        
        # ‡∏´‡∏¢‡∏∏‡∏î gimbal
        self.ep_gimbal.drive_speed(yaw_speed=0, pitch_speed=0)
        print("‚è∞ ‡∏´‡∏°‡∏î‡πÄ‡∏ß‡∏•‡∏≤‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°")
        return False
    
    def scan_and_shoot_in_direction(self, yaw_angle, scan_time=3.0, robot_position=None):
        """
        ‡∏™‡πÅ‡∏Å‡∏ô‡πÅ‡∏•‡∏∞‡∏¢‡∏¥‡∏á‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡πÉ‡∏ô‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î
        
        Args:
            yaw_angle: ‡∏°‡∏∏‡∏° yaw ‡∏ó‡∏µ‡πà‡∏à‡∏∞‡∏™‡πÅ‡∏Å‡∏ô
            scan_time: ‡πÄ‡∏ß‡∏•‡∏≤‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡πÅ‡∏Å‡∏ô (‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ)
            robot_position: ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏Ç‡∏≠‡∏á‡∏´‡∏∏‡πà‡∏ô‡∏¢‡∏ô‡∏ï‡πå
        
        Returns:
            bool: True ‡∏ñ‡πâ‡∏≤‡∏û‡∏ö‡πÅ‡∏•‡∏∞‡∏¢‡∏¥‡∏á‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏, False ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏û‡∏ö
        """
        print(f"üîç ‡∏™‡πÅ‡∏Å‡∏ô‡∏´‡∏≤‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡πÉ‡∏ô‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á {yaw_angle} ‡∏≠‡∏á‡∏®‡∏≤")
        
        # ‡πÄ‡∏•‡∏∑‡πà‡∏≠‡∏ô gimbal ‡πÑ‡∏õ‡∏¢‡∏±‡∏á‡∏ó‡∏¥‡∏®‡∏ó‡∏≤‡∏á‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î
        self.ep_gimbal.moveto(pitch=0, yaw=yaw_angle, pitch_speed=200, yaw_speed=200).wait_for_completed()
        time.sleep(0.3)
        
        scan_start_time = time.time()
        object_detected = False
        target_acquired = False
        
        while time.time() - scan_start_time < scan_time:
            try:
                img = self.ep_camera.read_cv2_image(strategy="newest", timeout=0.1)
                if img is not None:
                    target_info, is_centered = process_frame_for_objects(img)
                    
                    if target_info:
                        print(f"üéØ ‡∏û‡∏ö‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏: {target_info['color']} {target_info['shape']} ‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏¢‡∏∞ {target_info['distance']:.1f}cm")
                        target_acquired = True
                        
                        if is_centered:
                            # ‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏≠‡∏¢‡∏π‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏•‡∏≤‡∏á - ‡∏¢‡∏¥‡∏á!
                            if self.fire_at_target(target_info, robot_position):
                                object_detected = True
                                break
                        else:
                            # ‡∏õ‡∏£‡∏±‡∏ö gimbal ‡πÑ‡∏õ‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢
                            yaw_speed = YAW_KP * target_info['x_offset']
                            pitch_speed = PITCH_KP * target_info['y_offset']
                            
                            # ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î
                            yaw_speed = np.clip(yaw_speed, -MAX_YAW_SPEED, MAX_YAW_SPEED)
                            pitch_speed = np.clip(pitch_speed, -MAX_PITCH_SPEED, MAX_PITCH_SPEED)
                            
                            self.ep_gimbal.drive_speed(yaw_speed=yaw_speed, pitch_speed=pitch_speed)
                            time.sleep(0.05)
                    else:
                        # ‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏ - ‡∏´‡∏¢‡∏∏‡∏î gimbal
                        self.ep_gimbal.drive_speed(yaw_speed=0, pitch_speed=0)
                        time.sleep(0.1)
                        
            except Exception as e:
                print(f"‚ö†Ô∏è ‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡πÅ‡∏Å‡∏ô: {e}")
                break
        
        # ‡∏ñ‡πâ‡∏≤‡∏û‡∏ö‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡πÅ‡∏ï‡πà‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏¢‡∏¥‡∏á ‡πÉ‡∏´‡πâ‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏à‡∏ô‡∏Å‡∏ß‡πà‡∏≤‡∏à‡∏∞‡∏¢‡∏¥‡∏á‡πÄ‡∏™‡∏£‡πá‡∏à
        if target_acquired and not object_detected:
            print("üéØ ‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢...")
            object_detected = self.track_and_shoot_target(target_info, max_tracking_time=8.0)
        
        # ‡∏´‡∏¢‡∏∏‡∏î gimbal ‡πÅ‡∏•‡∏∞‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏™‡πÅ‡∏Å‡∏ô
        self.ep_gimbal.drive_speed(yaw_speed=0, pitch_speed=0)
        if object_detected:
            # ‡∏ñ‡πâ‡∏≤‡πÄ‡∏û‡∏¥‡πà‡∏á‡∏¢‡∏¥‡∏á‡πÄ‡∏™‡∏£‡πá‡∏à ‡πÉ‡∏´‡πâ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏™‡πÅ‡∏Å‡∏ô
            self.ep_gimbal.moveto(pitch=0, yaw=yaw_angle, pitch_speed=200, yaw_speed=200).wait_for_completed()
        
        return object_detected
    
    def scan_low_objects(self, robot_position=None):
        """
        ‡∏™‡πÅ‡∏Å‡∏ô‡∏´‡∏≤‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏ó‡∏µ‡πà‡∏≠‡∏¢‡∏π‡πà‡∏ï‡πà‡∏≥‡∏Å‡∏ß‡πà‡∏≤‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà ROI ‡∏õ‡∏Å‡∏ï‡∏¥
        
        Args:
            robot_position: ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏Ç‡∏≠‡∏á‡∏´‡∏∏‡πà‡∏ô‡∏¢‡∏ô‡∏ï‡πå
        
        Returns:
            bool: True ‡∏ñ‡πâ‡∏≤‡∏û‡∏ö‡πÅ‡∏•‡∏∞‡∏¢‡∏¥‡∏á‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏, False ‡∏ñ‡πâ‡∏≤‡πÑ‡∏°‡πà‡∏û‡∏ö
        """
        print(f"\nüîç Scanning for low objects...")
        
        # ‡∏õ‡∏£‡∏±‡∏ö gimbal ‡∏•‡∏á‡πÄ‡∏•‡πá‡∏Å‡∏ô‡πâ‡∏≠‡∏¢‡πÄ‡∏û‡∏∑‡πà‡∏≠‡∏î‡∏π‡∏û‡∏∑‡πâ‡∏ô‡∏ó‡∏µ‡πà‡∏ï‡πà‡∏≥‡∏Å‡∏ß‡πà‡∏≤
        original_pitch = 0
        scan_pitch = -15  # ‡∏•‡∏á‡∏°‡∏≤ 15 ‡∏≠‡∏á‡∏®‡∏≤
        
        try:
            self.ep_gimbal.moveto(pitch=scan_pitch, yaw=0, pitch_speed=100, yaw_speed=100).wait_for_completed()
            time.sleep(0.3)
            
            # ‡∏™‡πÅ‡∏Å‡∏ô‡∏´‡∏≤‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡πÉ‡∏ô‡∏°‡∏∏‡∏°‡∏ï‡πà‡∏≥
            scan_start_time = time.time()
            object_detected = False
            target_acquired = False
            
            while time.time() - scan_start_time < 2.0:  # ‡∏™‡πÅ‡∏Å‡∏ô‡πÄ‡∏õ‡πá‡∏ô‡πÄ‡∏ß‡∏•‡∏≤ 2 ‡∏ß‡∏¥‡∏ô‡∏≤‡∏ó‡∏µ
                try:
                    img = self.ep_camera.read_cv2_image(strategy="newest", timeout=0.1)
                    if img is not None:
                        target_info, is_centered = process_frame_for_objects(img)
                        
                        if target_info:
                            print(f"üéØ ‡∏û‡∏ö‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡πÉ‡∏ô‡∏°‡∏∏‡∏°‡∏ï‡πà‡∏≥: {target_info['color']} {target_info['shape']} ‡∏ó‡∏µ‡πà‡∏£‡∏∞‡∏¢‡∏∞ {target_info['distance']:.1f}cm")
                            target_acquired = True
                            
                            if is_centered:
                                # ‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏≠‡∏¢‡∏π‡πà‡∏ï‡∏£‡∏á‡∏Å‡∏•‡∏≤‡∏á - ‡∏¢‡∏¥‡∏á!
                                if self.fire_at_target(target_info, robot_position):
                                    object_detected = True
                                    break
                            else:
                                # ‡∏õ‡∏£‡∏±‡∏ö gimbal ‡πÑ‡∏õ‡∏ó‡∏µ‡πà‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢
                                yaw_speed = YAW_KP * target_info['x_offset']
                                pitch_speed = PITCH_KP * target_info['y_offset']
                                
                                # ‡∏à‡∏≥‡∏Å‡∏±‡∏î‡∏Ñ‡∏ß‡∏≤‡∏°‡πÄ‡∏£‡πá‡∏ß‡∏™‡∏π‡∏á‡∏™‡∏∏‡∏î
                                yaw_speed = np.clip(yaw_speed, -MAX_YAW_SPEED, MAX_YAW_SPEED)
                                pitch_speed = np.clip(pitch_speed, -MAX_PITCH_SPEED, MAX_PITCH_SPEED)
                                
                                self.ep_gimbal.drive_speed(yaw_speed=yaw_speed, pitch_speed=pitch_speed)
                                time.sleep(0.05)
                        else:
                            # ‡πÑ‡∏°‡πà‡πÄ‡∏à‡∏≠‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏ - ‡∏´‡∏¢‡∏∏‡∏î gimbal
                            self.ep_gimbal.drive_speed(yaw_speed=0, pitch_speed=0)
                            time.sleep(0.1)
                            
                except Exception as e:
                    print(f"‚ö†Ô∏è ‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡πÅ‡∏Å‡∏ô‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡πÉ‡∏ô‡∏°‡∏∏‡∏°‡∏ï‡πà‡∏≥: {e}")
                    break
            
            # ‡∏ñ‡πâ‡∏≤‡∏û‡∏ö‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡πÅ‡∏ï‡πà‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏¢‡∏¥‡∏á ‡πÉ‡∏´‡πâ‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏à‡∏ô‡∏Å‡∏ß‡πà‡∏≤‡∏à‡∏∞‡∏¢‡∏¥‡∏á‡πÄ‡∏™‡∏£‡πá‡∏à
            if target_acquired and not object_detected:
                print("üéØ ‡∏ï‡πà‡∏≠‡πÄ‡∏ô‡∏∑‡πà‡∏≠‡∏á‡∏Å‡∏≤‡∏£‡∏ï‡∏¥‡∏î‡∏ï‡∏≤‡∏°‡πÄ‡∏õ‡πâ‡∏≤‡∏´‡∏°‡∏≤‡∏¢‡πÉ‡∏ô‡∏°‡∏∏‡∏°‡∏ï‡πà‡∏≥...")
                object_detected = self.track_and_shoot_target(target_info, max_tracking_time=8.0)
            
            # ‡∏´‡∏¢‡∏∏‡∏î gimbal ‡πÅ‡∏•‡∏∞‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏õ‡∏Å‡∏ï‡∏¥
            self.ep_gimbal.drive_speed(yaw_speed=0, pitch_speed=0)
            self.ep_gimbal.moveto(pitch=original_pitch, yaw=0, pitch_speed=100, yaw_speed=100).wait_for_completed()
            
            if object_detected:
                print("‚úÖ ‡∏û‡∏ö‡πÅ‡∏•‡∏∞‡∏¢‡∏¥‡∏á‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡πÉ‡∏ô‡∏°‡∏∏‡∏°‡∏ï‡πà‡∏≥‡πÄ‡∏™‡∏£‡πá‡∏à‡∏™‡∏¥‡πâ‡∏ô")
            else:
                print("‚ÑπÔ∏è ‡πÑ‡∏°‡πà‡∏û‡∏ö‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡πÉ‡∏ô‡∏°‡∏∏‡∏°‡∏ï‡πà‡∏≥")
                
            return object_detected
                
        except Exception as e:
            print(f"‚ö†Ô∏è ‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏™‡πÅ‡∏Å‡∏ô‡∏°‡∏∏‡∏°‡∏ï‡πà‡∏≥: {e}")
            # ‡∏Å‡∏•‡∏±‡∏ö‡πÑ‡∏õ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á‡∏õ‡∏Å‡∏ï‡∏¥‡πÉ‡∏ô‡∏Å‡∏£‡∏ì‡∏µ‡πÄ‡∏Å‡∏¥‡∏î‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î
            try:
                self.ep_gimbal.moveto(pitch=original_pitch, yaw=0, pitch_speed=100, yaw_speed=100).wait_for_completed()
            except:
                pass
            return False

#############################
# Shot Object Tracking Functions
#############################

def record_shot_object(target_info, robot_position):
    """‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏¢‡∏¥‡∏á"""
    global shot_objects
    
    if target_info is None:
        return
    
    cell_pos = tuple(robot_position)
    shot_data = {
        'color': target_info['color'],
        'shape': target_info['shape'],
        'distance': target_info['distance'],
        'timestamp': datetime.now(),
        'x_offset': target_info.get('x_offset', 0),
        'y_offset': target_info.get('y_offset', 0)
    }
    
    with shot_objects_lock:
        if cell_pos not in shot_objects:
            shot_objects[cell_pos] = []
        shot_objects[cell_pos].append(shot_data)
    
    print(f"üìù ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏¢‡∏¥‡∏á: {target_info['color']} {target_info['shape']} ‡∏ó‡∏µ‡πà‡πÄ‡∏ã‡∏•‡∏•‡πå {cell_pos}")

def get_shot_objects_in_cell(cell_pos):
    """‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏¢‡∏¥‡∏á‡πÉ‡∏ô‡πÄ‡∏ã‡∏•‡∏•‡πå‡∏ó‡∏µ‡πà‡∏Å‡∏≥‡∏´‡∏ô‡∏î"""
    with shot_objects_lock:
        return shot_objects.get(tuple(cell_pos), [])

def get_all_shot_objects():
    """‡∏î‡∏∂‡∏á‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏¢‡∏¥‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î"""
    with shot_objects_lock:
        return dict(shot_objects)

def save_shot_objects(filename="shot_objects.csv"):
    """‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏¢‡∏¥‡∏á‡∏•‡∏á CSV"""
    try:
        with open(filename, 'w', newline='', encoding='utf-8') as f:
            writer = csv.writer(f)
            writer.writerow(['cell_x', 'cell_y', 'color', 'shape', 'distance', 'timestamp', 'x_offset', 'y_offset'])
            
            with shot_objects_lock:
                for (cell_x, cell_y), objects in shot_objects.items():
                    for obj in objects:
                        writer.writerow([
                            cell_x, cell_y,
                            obj['color'], obj['shape'],
                            obj['distance'], obj['timestamp'],
                            obj['x_offset'], obj['y_offset']
                        ])
        
        print(f"üíæ ‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡∏Ç‡πâ‡∏≠‡∏°‡∏π‡∏•‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏¢‡∏¥‡∏á‡∏•‡∏á‡πÑ‡∏ü‡∏•‡πå {filename}")
        
    except Exception as e:
        print(f"‚ö†Ô∏è ‡∏Ç‡πâ‡∏≠‡∏ú‡∏¥‡∏î‡∏û‡∏•‡∏≤‡∏î‡πÉ‡∏ô‡∏Å‡∏≤‡∏£‡∏ö‡∏±‡∏ô‡∏ó‡∏∂‡∏Å‡πÑ‡∏ü‡∏•‡πå: {e}")

#############################
# Utility Functions
#############################

def create_trackbar_window():
    """‡∏™‡∏£‡πâ‡∏≤‡∏á‡∏´‡∏ô‡πâ‡∏≤‡∏ï‡πà‡∏≤‡∏á trackbar ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö‡∏õ‡∏£‡∏±‡∏ö‡∏Ñ‡πà‡∏≤‡∏™‡∏µ"""
    cv2.namedWindow('Color Range Adjustment', cv2.WINDOW_NORMAL)
    
    # ‡∏™‡∏£‡πâ‡∏≤‡∏á trackbars ‡∏™‡∏≥‡∏´‡∏£‡∏±‡∏ö H, S, V (lower ‡πÅ‡∏•‡∏∞ upper)
    cv2.createTrackbar('H Lower', 'Color Range Adjustment', 0, 179, lambda x: None)
    cv2.createTrackbar('S Lower', 'Color Range Adjustment', 0, 255, lambda x: None)
    cv2.createTrackbar('V Lower', 'Color Range Adjustment', 0, 255, lambda x: None)
    cv2.createTrackbar('H Upper', 'Color Range Adjustment', 179, 179, lambda x: None)
    cv2.createTrackbar('S Upper', 'Color Range Adjustment', 255, 255, lambda x: None)
    cv2.createTrackbar('V Upper', 'Color Range Adjustment', 255, 255, lambda x: None)
    
    # ‡∏ï‡∏±‡πâ‡∏á‡∏Ñ‡πà‡∏≤‡πÄ‡∏£‡∏¥‡πà‡∏°‡∏ï‡πâ‡∏ô‡∏à‡∏≤‡∏Å‡∏™‡∏µ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô
    update_trackbars_from_current_color()

def update_trackbars_from_current_color():
    """‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï trackbar ‡πÉ‡∏´‡πâ‡∏ï‡∏£‡∏á‡∏Å‡∏±‡∏ö‡∏™‡∏µ‡∏õ‡∏±‡∏à‡∏à‡∏∏‡∏ö‡∏±‡∏ô"""
    global current_color_index
    current_color = color_names[current_color_index]
    lower, upper, _ = color_ranges[current_color]
    
    cv2.setTrackbarPos('H Lower', 'Color Range Adjustment', lower[0])
    cv2.setTrackbarPos('S Lower', 'Color Range Adjustment', lower[1])
    cv2.setTrackbarPos('V Lower', 'Color Range Adjustment', lower[2])
    cv2.setTrackbarPos('H Upper', 'Color Range Adjustment', upper[0])
    cv2.setTrackbarPos('S Upper', 'Color Range Adjustment', upper[1])
    cv2.setTrackbarPos('V Upper', 'Color Range Adjustment', upper[2])

def update_color_range():
    """‡∏≠‡∏±‡∏õ‡πÄ‡∏î‡∏ï‡∏ä‡πà‡∏ß‡∏á‡∏™‡∏µ‡∏à‡∏≤‡∏Å trackbar"""
    global current_color_index, color_ranges
    
    try:
        h_lower = cv2.getTrackbarPos('H Lower', 'Color Range Adjustment')
        s_lower = cv2.getTrackbarPos('S Lower', 'Color Range Adjustment')
        v_lower = cv2.getTrackbarPos('V Lower', 'Color Range Adjustment')
        h_upper = cv2.getTrackbarPos('H Upper', 'Color Range Adjustment')
        s_upper = cv2.getTrackbarPos('S Upper', 'Color Range Adjustment')
        v_upper = cv2.getTrackbarPos('V Upper', 'Color Range Adjustment')
        
        current_color = color_names[current_color_index]
        lower = [h_lower, s_lower, v_lower]
        upper = [h_upper, s_upper, v_upper]
        box_color = color_ranges[current_color][2]  # ‡πÄ‡∏Å‡πá‡∏ö‡∏™‡∏µ‡∏Ç‡∏≠‡∏á‡∏Å‡∏£‡∏≠‡∏ö‡πÄ‡∏î‡∏¥‡∏°
        
        color_ranges[current_color] = (lower, upper, box_color)
        
    except:
        pass  # ‡∏ñ‡πâ‡∏≤ trackbar ‡∏¢‡∏±‡∏á‡πÑ‡∏°‡πà‡πÑ‡∏î‡πâ‡∏™‡∏£‡πâ‡∏≤‡∏á ‡πÉ‡∏´‡πâ‡∏Ç‡πâ‡∏≤‡∏°‡πÑ‡∏õ

def print_shot_objects_summary():
    """‡πÅ‡∏™‡∏î‡∏á‡∏™‡∏£‡∏∏‡∏õ‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏¢‡∏¥‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î"""
    print("\n" + "="*60)
    print("üìä ‡∏™‡∏£‡∏∏‡∏õ‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏¢‡∏¥‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î")
    print("="*60)
    
    with shot_objects_lock:
        if not shot_objects:
            print("   ‡πÑ‡∏°‡πà‡∏°‡∏µ‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏¢‡∏¥‡∏á")
            return
        
        total_objects = 0
        for cell_pos, objects in shot_objects.items():
            total_objects += len(objects)
            print(f"\nüìç ‡πÄ‡∏ã‡∏•‡∏•‡πå {cell_pos}:")
            print(f"   ‚Ä¢ ‡∏à‡∏≥‡∏ô‡∏ß‡∏ô‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏¢‡∏¥‡∏á: {len(objects)}")
            print(f"   ‚Ä¢ ‡∏£‡∏≤‡∏¢‡∏•‡∏∞‡πÄ‡∏≠‡∏µ‡∏¢‡∏î‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡πÉ‡∏ô‡πÅ‡∏ï‡πà‡∏•‡∏∞‡πÄ‡∏ã‡∏•‡∏•‡πå:")
            
            for i, obj in enumerate(objects, 1):
                print(f"     {i}. {obj['color']} {obj['shape']} - ‡∏£‡∏∞‡∏¢‡∏∞ {obj['distance']:.1f}cm")
                print(f"        ‡πÄ‡∏ß‡∏•‡∏≤: {obj['timestamp'].strftime('%H:%M:%S')}")
                print(f"        ‡∏ï‡∏≥‡πÅ‡∏´‡∏ô‡πà‡∏á: ({obj['x_offset']}, {obj['y_offset']})")
        
        print(f"\nüéØ ‡∏£‡∏ß‡∏°‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏‡∏ó‡∏µ‡πà‡∏ñ‡∏π‡∏Å‡∏¢‡∏¥‡∏á‡∏ó‡∏±‡πâ‡∏á‡∏´‡∏°‡∏î: {total_objects} ‡∏ß‡∏±‡∏ï‡∏ñ‡∏∏")
        print("="*60)

if __name__ == "__main__":
    print("üéØ Shooting System Module")
    print("‡πÉ‡∏ä‡πâ‡πÇ‡∏°‡∏î‡∏π‡∏•‡∏ô‡∏µ‡πâ‡πÇ‡∏î‡∏¢‡∏Å‡∏≤‡∏£ import ‡πÉ‡∏ô‡πÑ‡∏ü‡∏•‡πå‡∏´‡∏•‡∏±‡∏Å")
    print("‡∏ï‡∏±‡∏ß‡∏≠‡∏¢‡πà‡∏≤‡∏á:")
    print("from shooting_system import ShootingSystem")
    print("shooting_system = ShootingSystem(ep_robot)")
